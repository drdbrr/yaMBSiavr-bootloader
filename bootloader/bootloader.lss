
bootloader.elf:     формат файла elf32-avr

Разделы:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000008  00800100  00007f3e  000007d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000073e  00007800  00007800  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .noinit       00000001  00800108  00800108  000007da  2**0
                  ALLOC
  3 .stab         00001830  00000000  00000000  000007dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001122  00000000  00000000  0000200c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000022  00000000  00000000  0000312e  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003150  2**2
                  CONTENTS, READONLY

Дизассемблирование раздела .text:

00007800 <__vectors>:
    7800:	33 c0       	rjmp	.+102    	; 0x7868 <__ctors_end>
    7802:	00 00       	nop
    7804:	53 c0       	rjmp	.+166    	; 0x78ac <__bad_interrupt>
    7806:	00 00       	nop
    7808:	51 c0       	rjmp	.+162    	; 0x78ac <__bad_interrupt>
    780a:	00 00       	nop
    780c:	4f c0       	rjmp	.+158    	; 0x78ac <__bad_interrupt>
    780e:	00 00       	nop
    7810:	4d c0       	rjmp	.+154    	; 0x78ac <__bad_interrupt>
    7812:	00 00       	nop
    7814:	4b c0       	rjmp	.+150    	; 0x78ac <__bad_interrupt>
    7816:	00 00       	nop
    7818:	49 c0       	rjmp	.+146    	; 0x78ac <__bad_interrupt>
    781a:	00 00       	nop
    781c:	47 c0       	rjmp	.+142    	; 0x78ac <__bad_interrupt>
    781e:	00 00       	nop
    7820:	45 c0       	rjmp	.+138    	; 0x78ac <__bad_interrupt>
    7822:	00 00       	nop
    7824:	43 c0       	rjmp	.+134    	; 0x78ac <__bad_interrupt>
    7826:	00 00       	nop
    7828:	41 c0       	rjmp	.+130    	; 0x78ac <__bad_interrupt>
    782a:	00 00       	nop
    782c:	3f c0       	rjmp	.+126    	; 0x78ac <__bad_interrupt>
    782e:	00 00       	nop
    7830:	3d c0       	rjmp	.+122    	; 0x78ac <__bad_interrupt>
    7832:	00 00       	nop
    7834:	3b c0       	rjmp	.+118    	; 0x78ac <__bad_interrupt>
    7836:	00 00       	nop
    7838:	39 c0       	rjmp	.+114    	; 0x78ac <__bad_interrupt>
    783a:	00 00       	nop
    783c:	37 c0       	rjmp	.+110    	; 0x78ac <__bad_interrupt>
    783e:	00 00       	nop
    7840:	35 c0       	rjmp	.+106    	; 0x78ac <__bad_interrupt>
    7842:	00 00       	nop
    7844:	33 c0       	rjmp	.+102    	; 0x78ac <__bad_interrupt>
    7846:	00 00       	nop
    7848:	31 c0       	rjmp	.+98     	; 0x78ac <__bad_interrupt>
    784a:	00 00       	nop
    784c:	2f c0       	rjmp	.+94     	; 0x78ac <__bad_interrupt>
    784e:	00 00       	nop
    7850:	2d c0       	rjmp	.+90     	; 0x78ac <__bad_interrupt>
    7852:	00 00       	nop
    7854:	2b c0       	rjmp	.+86     	; 0x78ac <__bad_interrupt>
    7856:	00 00       	nop
    7858:	29 c0       	rjmp	.+82     	; 0x78ac <__bad_interrupt>
    785a:	00 00       	nop
    785c:	27 c0       	rjmp	.+78     	; 0x78ac <__bad_interrupt>
    785e:	00 00       	nop
    7860:	25 c0       	rjmp	.+74     	; 0x78ac <__bad_interrupt>
    7862:	00 00       	nop
    7864:	23 c0       	rjmp	.+70     	; 0x78ac <__bad_interrupt>
	...

00007868 <__ctors_end>:
    7868:	11 24       	eor	r1, r1
    786a:	1f be       	out	0x3f, r1	; 63
    786c:	cf ef       	ldi	r28, 0xFF	; 255
    786e:	d8 e0       	ldi	r29, 0x08	; 8
    7870:	de bf       	out	0x3e, r29	; 62
    7872:	cd bf       	out	0x3d, r28	; 61

00007874 <get_mcusr>:
    7874:	84 b7       	in	r24, 0x34	; 52
    7876:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__data_end>
    787a:	14 be       	out	0x34, r1	; 52
    787c:	0f b6       	in	r0, 0x3f	; 63
    787e:	f8 94       	cli
    7880:	a8 95       	wdr
    7882:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    7886:	88 61       	ori	r24, 0x18	; 24
    7888:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    788c:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    7890:	0f be       	out	0x3f, r0	; 63

00007892 <__do_copy_data>:
    7892:	11 e0       	ldi	r17, 0x01	; 1
    7894:	a0 e0       	ldi	r26, 0x00	; 0
    7896:	b1 e0       	ldi	r27, 0x01	; 1
    7898:	ee e3       	ldi	r30, 0x3E	; 62
    789a:	ff e7       	ldi	r31, 0x7F	; 127
    789c:	02 c0       	rjmp	.+4      	; 0x78a2 <__do_copy_data+0x10>
    789e:	05 90       	lpm	r0, Z+
    78a0:	0d 92       	st	X+, r0
    78a2:	a8 30       	cpi	r26, 0x08	; 8
    78a4:	b1 07       	cpc	r27, r17
    78a6:	d9 f7       	brne	.-10     	; 0x789e <__do_copy_data+0xc>
    78a8:	e0 d1       	rcall	.+960    	; 0x7c6a <main>
    78aa:	47 c3       	rjmp	.+1678   	; 0x7f3a <_exit>

000078ac <__bad_interrupt>:
    78ac:	a9 cf       	rjmp	.-174    	; 0x7800 <__vectors>

000078ae <writeToPageBuffer>:
  } while (ptr);
  //wdt_reset();
}

static inline void erasePage(const uint16_t address) {
  boot_page_erase(address);
    78ae:	23 e0       	ldi	r18, 0x03	; 3
    78b0:	fc 01       	movw	r30, r24
    78b2:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78b6:	e8 95       	spm
  boot_spm_busy_wait();
    78b8:	07 b6       	in	r0, 0x37	; 55
    78ba:	00 fc       	sbrc	r0, 0
    78bc:	fd cf       	rjmp	.-6      	; 0x78b8 <writeToPageBuffer+0xa>
    78be:	db 01       	movw	r26, r22
}

static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    78c0:	60 e0       	ldi	r22, 0x00	; 0
    uint16_t w = *data++;
    w += (*data++) << 8;
    boot_page_fill(address + i, w);
    78c2:	71 e0       	ldi	r23, 0x01	; 1
    78c4:	ac 01       	movw	r20, r24
    78c6:	4a 1b       	sub	r20, r26
    78c8:	5b 0b       	sbc	r21, r27
    uint16_t w = *data++;
    78ca:	8c 91       	ld	r24, X
    boot_page_fill(address + i, w);
    78cc:	fa 01       	movw	r30, r20
    78ce:	ea 0f       	add	r30, r26
    78d0:	fb 1f       	adc	r31, r27
    w += (*data++) << 8;
    78d2:	11 96       	adiw	r26, 0x01	; 1
    78d4:	9c 91       	ld	r25, X
    78d6:	11 97       	sbiw	r26, 0x01	; 1
    78d8:	29 2f       	mov	r18, r25
    78da:	30 e0       	ldi	r19, 0x00	; 0
    78dc:	32 2f       	mov	r19, r18
    78de:	22 27       	eor	r18, r18
    78e0:	28 0f       	add	r18, r24
    78e2:	31 1d       	adc	r19, r1
    boot_page_fill(address + i, w);
    78e4:	09 01       	movw	r0, r18
    78e6:	70 93 57 00 	sts	0x0057, r23	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78ea:	e8 95       	spm
    78ec:	11 24       	eor	r1, r1
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    78ee:	6e 5f       	subi	r22, 0xFE	; 254
    78f0:	12 96       	adiw	r26, 0x02	; 2
    78f2:	60 38       	cpi	r22, 0x80	; 128
    78f4:	51 f7       	brne	.-44     	; 0x78ca <writeToPageBuffer+0x1c>
  }
}
    78f6:	08 95       	ret

000078f8 <writePageBufferToFlash>:

static inline void writePageBufferToFlash(const uint16_t address) {
  boot_page_write(address);
    78f8:	25 e0       	ldi	r18, 0x05	; 5
    78fa:	fc 01       	movw	r30, r24
    78fc:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7900:	e8 95       	spm
  boot_spm_busy_wait();
    7902:	07 b6       	in	r0, 0x37	; 55
    7904:	00 fc       	sbrc	r0, 0
    7906:	fd cf       	rjmp	.-6      	; 0x7902 <writePageBufferToFlash+0xa>
  boot_rww_enable();
    7908:	81 e1       	ldi	r24, 0x11	; 17
    790a:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    790e:	e8 95       	spm
}
    7910:	08 95       	ret

00007912 <twi_master_init>:
/*******************************************************************************
Call this function to init the TWI hardware.
*******************************************************************************/
void twi_master_init()
{
  TWSR = TWI_TWPS;
    7912:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
  TWBR = TWI_TWBR;
    7916:	8c e5       	ldi	r24, 0x5C	; 92
    7918:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
  uart_puts(buf);
  uart_putc('\n');
  //printf("\ntwi_master_init: F_SCL=%ld Hz, TWBR=%ld\n", TWI_SCL_CLOCK,
  //  TWI_TWBR);
#endif
}
    791c:	08 95       	ret

0000791e <twi_master_start>:
  char buf[10];
  uart_puts_P("\ntwi_start: ");
  //printf_P(PSTR("\ntwi_start:\t\t"));
#endif
  // send START condition
  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
    791e:	84 ea       	ldi	r24, 0xA4	; 164
    7920:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  uint16_t timeout = 1;
    7924:	21 e0       	ldi	r18, 0x01	; 1
    7926:	30 e0       	ldi	r19, 0x00	; 0
  // TODO fully interrupt driven routines
  // wait until transmission is completed
  while (!(TWCR & _BV(TWINT)) && timeout)
    7928:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    792c:	87 fd       	sbrc	r24, 7
    792e:	03 c0       	rjmp	.+6      	; 0x7936 <twi_master_start+0x18>
    7930:	21 15       	cp	r18, r1
    7932:	31 05       	cpc	r19, r1
    7934:	51 f4       	brne	.+20     	; 0x794a <twi_master_start+0x2c>
    timeout++;
  // check value of TWI Status Register. Mask prescaler bits.
  twst = TW_STATUS;
    7936:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
#ifdef TWI_DEBUG
  //twi_master_print_status();
#endif
  if (timeout == 0)
    793a:	23 2b       	or	r18, r19
    793c:	49 f0       	breq	.+18     	; 0x7950 <twi_master_start+0x32>
  twst = TW_STATUS;
    793e:	88 7f       	andi	r24, 0xF8	; 248
    uart_putc('\n');
    //printf(",\t\tcycles: %2d\n", timeout);
  }
#endif

  return ((twst == TW_START) || (twst == TW_REP_START)) ? twst : 0;
    7940:	88 30       	cpi	r24, 0x08	; 8
    7942:	39 f0       	breq	.+14     	; 0x7952 <twi_master_start+0x34>
    7944:	80 31       	cpi	r24, 0x10	; 16
    7946:	21 f4       	brne	.+8      	; 0x7950 <twi_master_start+0x32>
    7948:	08 95       	ret
    timeout++;
    794a:	2f 5f       	subi	r18, 0xFF	; 255
    794c:	3f 4f       	sbci	r19, 0xFF	; 255
    794e:	ec cf       	rjmp	.-40     	; 0x7928 <twi_master_start+0xa>
  return ((twst == TW_START) || (twst == TW_REP_START)) ? twst : 0;
    7950:	80 e0       	ldi	r24, 0x00	; 0
}
    7952:	08 95       	ret

00007954 <twi_master_stop>:
/*******************************************************************************
Transmit STOP condition and reset TWI interface.
*******************************************************************************/
void twi_master_stop()
{
  TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    7954:	84 e9       	ldi	r24, 0x94	; 148
    7956:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
#ifdef TWI_DEBUG
  uart_puts_P("twi_stop\n");
  //printf_P(PSTR("twi_stop\n"));
#endif
}
    795a:	08 95       	ret

0000795c <twi_master_write>:
  uart_puts(buf);
  uart_puts_P("]: ");
  //printf("twi_write[0x%2X]:\t", data);
#endif
  // Set TWI registers and start transmission of data
  TWDR = data;
    795c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
  TWCR = _BV(TWINT) | _BV(TWEN);
    7960:	84 e8       	ldi	r24, 0x84	; 132
    7962:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  uint16_t timeout = 1;
    7966:	21 e0       	ldi	r18, 0x01	; 1
    7968:	30 e0       	ldi	r19, 0x00	; 0
  // wail until transmission is completed and ACK/NACK has been received
  while (!(TWCR & _BV(TWINT)) && timeout)
    796a:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    796e:	87 fd       	sbrc	r24, 7
    7970:	03 c0       	rjmp	.+6      	; 0x7978 <twi_master_write+0x1c>
    7972:	21 15       	cp	r18, r1
    7974:	31 05       	cpc	r19, r1
    7976:	61 f4       	brne	.+24     	; 0x7990 <twi_master_write+0x34>
    timeout++;
  // check value of TWI Status Register. Mask prescaler bits.
  twst = TW_STATUS;
    7978:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
#ifdef TWI_DEBUG
  //twi_master_print_status();
#endif
  if (timeout == 0)
    797c:	23 2b       	or	r18, r19
    797e:	59 f0       	breq	.+22     	; 0x7996 <twi_master_write+0x3a>
  twst = TW_STATUS;
    7980:	88 7f       	andi	r24, 0xF8	; 248
    //printf(",\t\tcycles: %d\n", timeout);
  }
#endif

  return (twst == TW_MT_SLA_ACK) || (twst == TW_MT_DATA_ACK) ||
         (twst == TW_MR_SLA_ACK) ? twst : 0;
    7982:	88 31       	cpi	r24, 0x18	; 24
    7984:	49 f0       	breq	.+18     	; 0x7998 <twi_master_write+0x3c>
  return (twst == TW_MT_SLA_ACK) || (twst == TW_MT_DATA_ACK) ||
    7986:	88 32       	cpi	r24, 0x28	; 40
    7988:	39 f0       	breq	.+14     	; 0x7998 <twi_master_write+0x3c>
    798a:	80 34       	cpi	r24, 0x40	; 64
    798c:	21 f4       	brne	.+8      	; 0x7996 <twi_master_write+0x3a>
    798e:	08 95       	ret
    timeout++;
    7990:	2f 5f       	subi	r18, 0xFF	; 255
    7992:	3f 4f       	sbci	r19, 0xFF	; 255
    7994:	ea cf       	rjmp	.-44     	; 0x796a <twi_master_write+0xe>
         (twst == TW_MR_SLA_ACK) ? twst : 0;
    7996:	80 e0       	ldi	r24, 0x00	; 0
}
    7998:	08 95       	ret

0000799a <twi_master_read>:
RETURN VALUE
  If no error occurs, this function returns the TWI Status Register value.
  On error, 0 is returned.
*******************************************************************************/
uint8_t twi_master_read(uint8_t *buf, const uint8_t ack)
{
    799a:	fc 01       	movw	r30, r24
  {
#ifdef TWI_DEBUG
    uart_puts_P("twi_read[TWI_ACK, ");
    //printf_P(PSTR("twi_read[TWI_ACK,"));
#endif
    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);
    799c:	84 ec       	ldi	r24, 0xC4	; 196
  if (ack)
    799e:	61 11       	cpse	r22, r1
    79a0:	01 c0       	rjmp	.+2      	; 0x79a4 <twi_master_read+0xa>
  {
#ifdef TWI_DEBUG
    uart_puts_P("twi_read[TWI_NAK, ");
    //printf_P(PSTR("twi_read[TWI_NAK,"));
#endif
    TWCR = _BV(TWINT) | _BV(TWEN);
    79a2:	84 e8       	ldi	r24, 0x84	; 132
    79a4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
{
    79a8:	21 e0       	ldi	r18, 0x01	; 1
    79aa:	30 e0       	ldi	r19, 0x00	; 0
  }
  // wait until reading completed
  while (!(TWCR & _BV(TWINT)) && timeout)
    79ac:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    79b0:	87 fd       	sbrc	r24, 7
    79b2:	03 c0       	rjmp	.+6      	; 0x79ba <twi_master_read+0x20>
    79b4:	21 15       	cp	r18, r1
    79b6:	31 05       	cpc	r19, r1
    79b8:	39 f4       	brne	.+14     	; 0x79c8 <twi_master_read+0x2e>
    timeout++;
  // check value of TWI Status Register. Mask prescaler bits.
  twst = TW_STATUS;
    79ba:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
  uart_puts(tmp_buf);
  uart_puts_P("]: ");
  //printf("0x%2X]:\t", TWDR);
  //twi_master_print_status();
#endif
  if (timeout == 0)
    79be:	23 2b       	or	r18, r19
    79c0:	31 f4       	brne	.+12     	; 0x79ce <twi_master_read+0x34>
  {
#ifdef TWI_DEBUG
    uart_puts_P(", TIMEOUT\n");
    //printf_P(PSTR(",\tTIMEOUT\n"));
#endif
    *buf = 0;
    79c2:	10 82       	st	Z, r1
    uart_putc('\n');
    //printf(",\tcycles: %d\n", timeout);
#endif
  }

  return (twst == TW_MR_DATA_ACK) || (twst == TW_MR_DATA_NACK) ? twst : 0;
    79c4:	80 e0       	ldi	r24, 0x00	; 0
    79c6:	0b c0       	rjmp	.+22     	; 0x79de <twi_master_read+0x44>
    timeout++;
    79c8:	2f 5f       	subi	r18, 0xFF	; 255
    79ca:	3f 4f       	sbci	r19, 0xFF	; 255
    79cc:	ef cf       	rjmp	.-34     	; 0x79ac <twi_master_read+0x12>
  twst = TW_STATUS;
    79ce:	88 7f       	andi	r24, 0xF8	; 248
    *buf = TWDR;
    79d0:	90 91 bb 00 	lds	r25, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    79d4:	90 83       	st	Z, r25
  return (twst == TW_MR_DATA_ACK) || (twst == TW_MR_DATA_NACK) ? twst : 0;
    79d6:	80 35       	cpi	r24, 0x50	; 80
    79d8:	11 f0       	breq	.+4      	; 0x79de <twi_master_read+0x44>
    79da:	88 35       	cpi	r24, 0x58	; 88
    79dc:	99 f7       	brne	.-26     	; 0x79c4 <twi_master_read+0x2a>
}
    79de:	08 95       	ret

000079e0 <twi_master_read16_reg8>:
/******************************************************************************
Write page to memory
*******************************************************************************/

uint8_t twi_master_read16_reg8(const uint8_t sad, const uint16_t reg_addr)
{
    79e0:	ff 92       	push	r15
    79e2:	0f 93       	push	r16
    79e4:	1f 93       	push	r17
    79e6:	cf 93       	push	r28
    79e8:	df 93       	push	r29
    79ea:	1f 92       	push	r1
    79ec:	cd b7       	in	r28, 0x3d	; 61
    79ee:	de b7       	in	r29, 0x3e	; 62
    79f0:	18 2f       	mov	r17, r24
    79f2:	06 2f       	mov	r16, r22
    79f4:	f7 2e       	mov	r15, r23
  uint8_t st = 1;
  uint8_t buf = 0b00000000;
  uint8_t value = 0;
    79f6:	19 82       	std	Y+1, r1	; 0x01
  
  st = st && twi_master_start();
    79f8:	92 df       	rcall	.-220    	; 0x791e <twi_master_start>
  st = st && twi_master_write((sad << 1) | TW_WRITE);
    79fa:	88 23       	and	r24, r24
    79fc:	c1 f1       	breq	.+112    	; 0x7a6e <twi_master_read16_reg8+0x8e>
    79fe:	81 2f       	mov	r24, r17
    7a00:	88 0f       	add	r24, r24
    7a02:	ac df       	rcall	.-168    	; 0x795c <twi_master_write>
    7a04:	21 e0       	ldi	r18, 0x01	; 1
    7a06:	30 e0       	ldi	r19, 0x00	; 0
    7a08:	81 11       	cpse	r24, r1
    7a0a:	02 c0       	rjmp	.+4      	; 0x7a10 <twi_master_read16_reg8+0x30>
    7a0c:	30 e0       	ldi	r19, 0x00	; 0
    7a0e:	20 e0       	ldi	r18, 0x00	; 0
  
  st = st && twi_master_write(reg_addr >> 8);
    7a10:	23 2b       	or	r18, r19
    7a12:	69 f1       	breq	.+90     	; 0x7a6e <twi_master_read16_reg8+0x8e>
    7a14:	8f 2d       	mov	r24, r15
    7a16:	a2 df       	rcall	.-188    	; 0x795c <twi_master_write>
    7a18:	21 e0       	ldi	r18, 0x01	; 1
    7a1a:	30 e0       	ldi	r19, 0x00	; 0
    7a1c:	81 11       	cpse	r24, r1
    7a1e:	02 c0       	rjmp	.+4      	; 0x7a24 <twi_master_read16_reg8+0x44>
    7a20:	30 e0       	ldi	r19, 0x00	; 0
    7a22:	20 e0       	ldi	r18, 0x00	; 0
  st = st && twi_master_write(reg_addr);
    7a24:	23 2b       	or	r18, r19
    7a26:	19 f1       	breq	.+70     	; 0x7a6e <twi_master_read16_reg8+0x8e>
    7a28:	80 2f       	mov	r24, r16
    7a2a:	98 df       	rcall	.-208    	; 0x795c <twi_master_write>
    7a2c:	21 e0       	ldi	r18, 0x01	; 1
    7a2e:	30 e0       	ldi	r19, 0x00	; 0
    7a30:	81 11       	cpse	r24, r1
    7a32:	02 c0       	rjmp	.+4      	; 0x7a38 <twi_master_read16_reg8+0x58>
    7a34:	30 e0       	ldi	r19, 0x00	; 0
    7a36:	20 e0       	ldi	r18, 0x00	; 0
  
  //twi_master_stop();
  //_delay_ms(1);
  st = st && twi_master_start();
    7a38:	23 2b       	or	r18, r19
    7a3a:	c9 f0       	breq	.+50     	; 0x7a6e <twi_master_read16_reg8+0x8e>
    7a3c:	70 df       	rcall	.-288    	; 0x791e <twi_master_start>
    7a3e:	21 e0       	ldi	r18, 0x01	; 1
    7a40:	30 e0       	ldi	r19, 0x00	; 0
    7a42:	81 11       	cpse	r24, r1
    7a44:	02 c0       	rjmp	.+4      	; 0x7a4a <twi_master_read16_reg8+0x6a>
    7a46:	30 e0       	ldi	r19, 0x00	; 0
    7a48:	20 e0       	ldi	r18, 0x00	; 0
  st = st && twi_master_write((sad << 1) | TW_READ);
    7a4a:	23 2b       	or	r18, r19
    7a4c:	81 f0       	breq	.+32     	; 0x7a6e <twi_master_read16_reg8+0x8e>
    7a4e:	81 2f       	mov	r24, r17
    7a50:	88 0f       	add	r24, r24
    7a52:	81 60       	ori	r24, 0x01	; 1
    7a54:	83 df       	rcall	.-250    	; 0x795c <twi_master_write>
    7a56:	21 e0       	ldi	r18, 0x01	; 1
    7a58:	30 e0       	ldi	r19, 0x00	; 0
    7a5a:	81 11       	cpse	r24, r1
    7a5c:	02 c0       	rjmp	.+4      	; 0x7a62 <twi_master_read16_reg8+0x82>
    7a5e:	30 e0       	ldi	r19, 0x00	; 0
    7a60:	20 e0       	ldi	r18, 0x00	; 0
  
  st = st && twi_master_read(&value, TWI_NAK);
    7a62:	23 2b       	or	r18, r19
    7a64:	21 f0       	breq	.+8      	; 0x7a6e <twi_master_read16_reg8+0x8e>
    7a66:	60 e0       	ldi	r22, 0x00	; 0
    7a68:	ce 01       	movw	r24, r28
    7a6a:	01 96       	adiw	r24, 0x01	; 1
    7a6c:	96 df       	rcall	.-212    	; 0x799a <twi_master_read>
  TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    7a6e:	84 e9       	ldi	r24, 0x94	; 148
    7a70:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  
  twi_master_stop();

  return value;
}
    7a74:	89 81       	ldd	r24, Y+1	; 0x01
    7a76:	0f 90       	pop	r0
    7a78:	df 91       	pop	r29
    7a7a:	cf 91       	pop	r28
    7a7c:	1f 91       	pop	r17
    7a7e:	0f 91       	pop	r16
    7a80:	ff 90       	pop	r15
    7a82:	08 95       	ret

00007a84 <twi_master_read16_reg16>:

uint16_t twi_master_read16_reg16(const uint8_t sad, const uint16_t reg_addr)
{
    7a84:	ff 92       	push	r15
    7a86:	0f 93       	push	r16
    7a88:	1f 93       	push	r17
    7a8a:	cf 93       	push	r28
    7a8c:	df 93       	push	r29
    7a8e:	1f 92       	push	r1
    7a90:	cd b7       	in	r28, 0x3d	; 61
    7a92:	de b7       	in	r29, 0x3e	; 62
    7a94:	18 2f       	mov	r17, r24
    7a96:	06 2f       	mov	r16, r22
    uint16_t buf = 0b0000000000000000;
    uint8_t value = 0;
    7a98:	f7 2e       	mov	r15, r23
  uint8_t st = 1;

  st = st && twi_master_start();
    7a9a:	19 82       	std	Y+1, r1	; 0x01
  st = st && twi_master_write((sad << 1) | TW_WRITE);
    7a9c:	40 df       	rcall	.-384    	; 0x791e <twi_master_start>
    7a9e:	88 23       	and	r24, r24
    7aa0:	09 f4       	brne	.+2      	; 0x7aa4 <twi_master_read16_reg16+0x20>
    7aa2:	3b c0       	rjmp	.+118    	; 0x7b1a <twi_master_read16_reg16+0x96>
    7aa4:	81 2f       	mov	r24, r17
    7aa6:	88 0f       	add	r24, r24
    7aa8:	59 df       	rcall	.-334    	; 0x795c <twi_master_write>
    7aaa:	21 e0       	ldi	r18, 0x01	; 1
    7aac:	30 e0       	ldi	r19, 0x00	; 0
    7aae:	81 11       	cpse	r24, r1
    7ab0:	02 c0       	rjmp	.+4      	; 0x7ab6 <twi_master_read16_reg16+0x32>
    7ab2:	30 e0       	ldi	r19, 0x00	; 0
  
  st = st && twi_master_write(reg_addr >> 8);
    7ab4:	20 e0       	ldi	r18, 0x00	; 0
    7ab6:	23 2b       	or	r18, r19
    7ab8:	81 f1       	breq	.+96     	; 0x7b1a <twi_master_read16_reg16+0x96>
    7aba:	8f 2d       	mov	r24, r15
    7abc:	4f df       	rcall	.-354    	; 0x795c <twi_master_write>
    7abe:	21 e0       	ldi	r18, 0x01	; 1
    7ac0:	30 e0       	ldi	r19, 0x00	; 0
    7ac2:	81 11       	cpse	r24, r1
    7ac4:	02 c0       	rjmp	.+4      	; 0x7aca <twi_master_read16_reg16+0x46>
    7ac6:	30 e0       	ldi	r19, 0x00	; 0
  st = st && twi_master_write(reg_addr);
    7ac8:	20 e0       	ldi	r18, 0x00	; 0
    7aca:	23 2b       	or	r18, r19
    7acc:	31 f1       	breq	.+76     	; 0x7b1a <twi_master_read16_reg16+0x96>
    7ace:	80 2f       	mov	r24, r16
    7ad0:	45 df       	rcall	.-374    	; 0x795c <twi_master_write>
    7ad2:	21 e0       	ldi	r18, 0x01	; 1
    7ad4:	30 e0       	ldi	r19, 0x00	; 0
    7ad6:	81 11       	cpse	r24, r1
    7ad8:	02 c0       	rjmp	.+4      	; 0x7ade <twi_master_read16_reg16+0x5a>
    7ada:	30 e0       	ldi	r19, 0x00	; 0
  
  st = st && twi_master_start();
    7adc:	20 e0       	ldi	r18, 0x00	; 0
    7ade:	23 2b       	or	r18, r19
    7ae0:	e1 f0       	breq	.+56     	; 0x7b1a <twi_master_read16_reg16+0x96>
    7ae2:	1d df       	rcall	.-454    	; 0x791e <twi_master_start>
    7ae4:	21 e0       	ldi	r18, 0x01	; 1
    7ae6:	30 e0       	ldi	r19, 0x00	; 0
    7ae8:	81 11       	cpse	r24, r1
    7aea:	02 c0       	rjmp	.+4      	; 0x7af0 <twi_master_read16_reg16+0x6c>
    7aec:	30 e0       	ldi	r19, 0x00	; 0
  st = st && twi_master_write((sad << 1) | TW_READ);
    7aee:	20 e0       	ldi	r18, 0x00	; 0
    7af0:	23 2b       	or	r18, r19
    7af2:	99 f0       	breq	.+38     	; 0x7b1a <twi_master_read16_reg16+0x96>
    7af4:	81 2f       	mov	r24, r17
    7af6:	88 0f       	add	r24, r24
    7af8:	81 60       	ori	r24, 0x01	; 1
    7afa:	30 df       	rcall	.-416    	; 0x795c <twi_master_write>
    7afc:	21 e0       	ldi	r18, 0x01	; 1
    7afe:	30 e0       	ldi	r19, 0x00	; 0
    7b00:	81 11       	cpse	r24, r1
    7b02:	02 c0       	rjmp	.+4      	; 0x7b08 <twi_master_read16_reg16+0x84>
    7b04:	30 e0       	ldi	r19, 0x00	; 0
  
    st = st && twi_master_read(&value, TWI_ACK);
    7b06:	20 e0       	ldi	r18, 0x00	; 0
    7b08:	23 2b       	or	r18, r19
    7b0a:	39 f0       	breq	.+14     	; 0x7b1a <twi_master_read16_reg16+0x96>
    7b0c:	61 e0       	ldi	r22, 0x01	; 1
    7b0e:	ce 01       	movw	r24, r28
    7b10:	01 96       	adiw	r24, 0x01	; 1
    7b12:	43 df       	rcall	.-378    	; 0x799a <twi_master_read>
    7b14:	91 e0       	ldi	r25, 0x01	; 1
    7b16:	81 11       	cpse	r24, r1
    7b18:	01 c0       	rjmp	.+2      	; 0x7b1c <twi_master_read16_reg16+0x98>
    7b1a:	90 e0       	ldi	r25, 0x00	; 0
    buf = (value << 8);
    7b1c:	09 81       	ldd	r16, Y+1	; 0x01
    7b1e:	10 e0       	ldi	r17, 0x00	; 0
    7b20:	10 2f       	mov	r17, r16
    
    st = st && twi_master_read(&value, TWI_NAK);
    7b22:	00 27       	eor	r16, r16
    7b24:	99 23       	and	r25, r25
    7b26:	21 f0       	breq	.+8      	; 0x7b30 <twi_master_read16_reg16+0xac>
    7b28:	60 e0       	ldi	r22, 0x00	; 0
    7b2a:	ce 01       	movw	r24, r28
    7b2c:	01 96       	adiw	r24, 0x01	; 1
    7b2e:	35 df       	rcall	.-406    	; 0x799a <twi_master_read>
    buf |= value;
    7b30:	89 81       	ldd	r24, Y+1	; 0x01
  TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWSTO);
    7b32:	94 e9       	ldi	r25, 0x94	; 148
    7b34:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    
  twi_master_stop();

  return buf;
}
    7b38:	98 01       	movw	r18, r16
    7b3a:	28 2b       	or	r18, r24
    7b3c:	c9 01       	movw	r24, r18
    7b3e:	0f 90       	pop	r0
    7b40:	df 91       	pop	r29
    7b42:	cf 91       	pop	r28
    7b44:	1f 91       	pop	r17
    7b46:	0f 91       	pop	r16
    7b48:	ff 90       	pop	r15
    7b4a:	08 95       	ret

00007b4c <twi_master_write16_reg8>:

uint8_t twi_master_write16_reg8(const uint8_t sad, const uint16_t reg_addr,
                              uint8_t data)
{
    7b4c:	0f 93       	push	r16
    7b4e:	1f 93       	push	r17
    7b50:	cf 93       	push	r28
    7b52:	df 93       	push	r29
    7b54:	08 2f       	mov	r16, r24
    7b56:	d6 2f       	mov	r29, r22
    7b58:	17 2f       	mov	r17, r23
    7b5a:	c4 2f       	mov	r28, r20
  uint8_t st = 1;
  
  st = st && twi_master_start();
    7b5c:	e0 de       	rcall	.-576    	; 0x791e <twi_master_start>
  
  st = st && twi_master_write((sad << 1) | TW_WRITE);
    7b5e:	88 23       	and	r24, r24
    7b60:	a1 f1       	breq	.+104    	; 0x7bca <twi_master_write16_reg8+0x7e>
    7b62:	80 2f       	mov	r24, r16
    7b64:	88 0f       	add	r24, r24
    7b66:	fa de       	rcall	.-524    	; 0x795c <twi_master_write>
    7b68:	21 e0       	ldi	r18, 0x01	; 1
    7b6a:	30 e0       	ldi	r19, 0x00	; 0
    7b6c:	81 11       	cpse	r24, r1
    7b6e:	02 c0       	rjmp	.+4      	; 0x7b74 <twi_master_write16_reg8+0x28>
    7b70:	30 e0       	ldi	r19, 0x00	; 0
    7b72:	20 e0       	ldi	r18, 0x00	; 0
  
  st = st && twi_master_write(reg_addr >> 8);
    7b74:	23 2b       	or	r18, r19
    7b76:	49 f1       	breq	.+82     	; 0x7bca <twi_master_write16_reg8+0x7e>
    7b78:	81 2f       	mov	r24, r17
    7b7a:	f0 de       	rcall	.-544    	; 0x795c <twi_master_write>
    7b7c:	21 e0       	ldi	r18, 0x01	; 1
    7b7e:	30 e0       	ldi	r19, 0x00	; 0
    7b80:	81 11       	cpse	r24, r1
    7b82:	02 c0       	rjmp	.+4      	; 0x7b88 <twi_master_write16_reg8+0x3c>
    7b84:	30 e0       	ldi	r19, 0x00	; 0
    7b86:	20 e0       	ldi	r18, 0x00	; 0
  st = st && twi_master_write(reg_addr);
    7b88:	23 2b       	or	r18, r19
    7b8a:	f9 f0       	breq	.+62     	; 0x7bca <twi_master_write16_reg8+0x7e>
    7b8c:	8d 2f       	mov	r24, r29
    7b8e:	e6 de       	rcall	.-564    	; 0x795c <twi_master_write>
    7b90:	21 e0       	ldi	r18, 0x01	; 1
    7b92:	30 e0       	ldi	r19, 0x00	; 0
    7b94:	81 11       	cpse	r24, r1
    7b96:	02 c0       	rjmp	.+4      	; 0x7b9c <twi_master_write16_reg8+0x50>
    7b98:	30 e0       	ldi	r19, 0x00	; 0
    7b9a:	20 e0       	ldi	r18, 0x00	; 0
    7b9c:	23 2b       	or	r18, r19
  
  st = st && twi_master_write(data);
    7b9e:	a9 f0       	breq	.+42     	; 0x7bca <twi_master_write16_reg8+0x7e>
    7ba0:	8c 2f       	mov	r24, r28
    7ba2:	dc de       	rcall	.-584    	; 0x795c <twi_master_write>
    7ba4:	91 e0       	ldi	r25, 0x01	; 1
    7ba6:	81 11       	cpse	r24, r1
    7ba8:	01 c0       	rjmp	.+2      	; 0x7bac <twi_master_write16_reg8+0x60>
    7baa:	90 e0       	ldi	r25, 0x00	; 0
    7bac:	89 2f       	mov	r24, r25
    7bae:	94 e9       	ldi	r25, 0x94	; 148
    7bb0:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7bb4:	ef e3       	ldi	r30, 0x3F	; 63
    7bb6:	fc e9       	ldi	r31, 0x9C	; 156
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    7bb8:	31 97       	sbiw	r30, 0x01	; 1
    7bba:	f1 f7       	brne	.-4      	; 0x7bb8 <twi_master_write16_reg8+0x6c>
    7bbc:	00 c0       	rjmp	.+0      	; 0x7bbe <twi_master_write16_reg8+0x72>
    7bbe:	00 00       	nop
    7bc0:	df 91       	pop	r29
  
  twi_master_stop();
  _delay_ms(10);
  return st;
}
    7bc2:	cf 91       	pop	r28
    7bc4:	1f 91       	pop	r17
    7bc6:	0f 91       	pop	r16
    7bc8:	08 95       	ret
    7bca:	80 e0       	ldi	r24, 0x00	; 0
  st = st && twi_master_write(data);
    7bcc:	f0 cf       	rjmp	.-32     	; 0x7bae <twi_master_write16_reg8+0x62>

00007bce <twi_master_write16_reg16>:
    7bce:	ff 92       	push	r15
    7bd0:	0f 93       	push	r16
    7bd2:	1f 93       	push	r17
    7bd4:	cf 93       	push	r28
    7bd6:	df 93       	push	r29
    7bd8:	f8 2e       	mov	r15, r24
    7bda:	16 2f       	mov	r17, r22
    7bdc:	07 2f       	mov	r16, r23
    7bde:	ea 01       	movw	r28, r20
    7be0:	9e de       	rcall	.-708    	; 0x791e <twi_master_start>
    7be2:	88 23       	and	r24, r24
    7be4:	09 f4       	brne	.+2      	; 0x7be8 <twi_master_write16_reg16+0x1a>
    7be6:	3f c0       	rjmp	.+126    	; 0x7c66 <twi_master_write16_reg16+0x98>
    7be8:	8f 2d       	mov	r24, r15
    7bea:	88 0f       	add	r24, r24
    7bec:	b7 de       	rcall	.-658    	; 0x795c <twi_master_write>
    7bee:	21 e0       	ldi	r18, 0x01	; 1
    7bf0:	30 e0       	ldi	r19, 0x00	; 0
    7bf2:	81 11       	cpse	r24, r1
    7bf4:	02 c0       	rjmp	.+4      	; 0x7bfa <twi_master_write16_reg16+0x2c>
    7bf6:	30 e0       	ldi	r19, 0x00	; 0
    7bf8:	20 e0       	ldi	r18, 0x00	; 0
    7bfa:	23 2b       	or	r18, r19
    7bfc:	a1 f1       	breq	.+104    	; 0x7c66 <twi_master_write16_reg16+0x98>
    7bfe:	80 2f       	mov	r24, r16
    7c00:	ad de       	rcall	.-678    	; 0x795c <twi_master_write>
    7c02:	21 e0       	ldi	r18, 0x01	; 1
    7c04:	30 e0       	ldi	r19, 0x00	; 0
    7c06:	81 11       	cpse	r24, r1
    7c08:	02 c0       	rjmp	.+4      	; 0x7c0e <twi_master_write16_reg16+0x40>
    7c0a:	30 e0       	ldi	r19, 0x00	; 0
    7c0c:	20 e0       	ldi	r18, 0x00	; 0
    7c0e:	23 2b       	or	r18, r19
    7c10:	51 f1       	breq	.+84     	; 0x7c66 <twi_master_write16_reg16+0x98>
    7c12:	81 2f       	mov	r24, r17
    7c14:	a3 de       	rcall	.-698    	; 0x795c <twi_master_write>
    7c16:	21 e0       	ldi	r18, 0x01	; 1
    7c18:	30 e0       	ldi	r19, 0x00	; 0
    7c1a:	81 11       	cpse	r24, r1
    7c1c:	02 c0       	rjmp	.+4      	; 0x7c22 <twi_master_write16_reg16+0x54>
    7c1e:	30 e0       	ldi	r19, 0x00	; 0
    7c20:	20 e0       	ldi	r18, 0x00	; 0
    7c22:	23 2b       	or	r18, r19
    7c24:	01 f1       	breq	.+64     	; 0x7c66 <twi_master_write16_reg16+0x98>
    7c26:	8d 2f       	mov	r24, r29
    7c28:	99 de       	rcall	.-718    	; 0x795c <twi_master_write>
    7c2a:	21 e0       	ldi	r18, 0x01	; 1
    7c2c:	30 e0       	ldi	r19, 0x00	; 0
    7c2e:	81 11       	cpse	r24, r1
    7c30:	02 c0       	rjmp	.+4      	; 0x7c36 <twi_master_write16_reg16+0x68>
    7c32:	30 e0       	ldi	r19, 0x00	; 0
    7c34:	20 e0       	ldi	r18, 0x00	; 0
    7c36:	23 2b       	or	r18, r19
    7c38:	b1 f0       	breq	.+44     	; 0x7c66 <twi_master_write16_reg16+0x98>
    7c3a:	8c 2f       	mov	r24, r28
    7c3c:	8f de       	rcall	.-738    	; 0x795c <twi_master_write>
    7c3e:	91 e0       	ldi	r25, 0x01	; 1
    7c40:	81 11       	cpse	r24, r1
    7c42:	01 c0       	rjmp	.+2      	; 0x7c46 <twi_master_write16_reg16+0x78>
    7c44:	90 e0       	ldi	r25, 0x00	; 0
    7c46:	89 2f       	mov	r24, r25
    7c48:	94 e9       	ldi	r25, 0x94	; 148
    7c4a:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7c4e:	ef e3       	ldi	r30, 0x3F	; 63
    7c50:	fc e9       	ldi	r31, 0x9C	; 156
    7c52:	31 97       	sbiw	r30, 0x01	; 1
    7c54:	f1 f7       	brne	.-4      	; 0x7c52 <twi_master_write16_reg16+0x84>
    7c56:	00 c0       	rjmp	.+0      	; 0x7c58 <twi_master_write16_reg16+0x8a>
    7c58:	00 00       	nop
    7c5a:	df 91       	pop	r29
    7c5c:	cf 91       	pop	r28
    7c5e:	1f 91       	pop	r17
    7c60:	0f 91       	pop	r16
    7c62:	ff 90       	pop	r15
    7c64:	08 95       	ret
    7c66:	80 e0       	ldi	r24, 0x00	; 0
    7c68:	ef cf       	rjmp	.-34     	; 0x7c48 <twi_master_write16_reg16+0x7a>

00007c6a <main>:

  writeToFlash(writes * SPM_PAGESIZE, &buf[0]); //, application_start);
}

int main(void) 
{
    7c6a:	cf 93       	push	r28
    7c6c:	df 93       	push	r29
    7c6e:	cd b7       	in	r28, 0x3d	; 61
    7c70:	de b7       	in	r29, 0x3e	; 62
    7c72:	c4 58       	subi	r28, 0x84	; 132
    7c74:	d1 09       	sbc	r29, r1
    7c76:	0f b6       	in	r0, 0x3f	; 63
    7c78:	f8 94       	cli
    7c7a:	de bf       	out	0x3e, r29	; 62
    7c7c:	0f be       	out	0x3f, r0	; 63
    7c7e:	cd bf       	out	0x3d, r28	; 61

  uint16_t application_start = 0;
  uint8_t dc =0;
  uint8_t crcc = 0;
  twi_master_init();
    7c80:	48 de       	rcall	.-880    	; 0x7912 <twi_master_init>
  MCUSR &= ~(1<<WDRF);
  WDTCSR |= (1<<WDCE) | (1<<WDE);
  WDTCSR = 0x00;
  */
  
  DDRB |= (1<<1);
    7c82:	21 9a       	sbi	0x04, 1	; 4
  PORTB |= (1<<1);
    7c84:	29 9a       	sbi	0x05, 1	; 5
  
  dc = twi_master_read16_reg8(ic_addr, 26);
    7c86:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ic_addr>
    7c8a:	6a e1       	ldi	r22, 0x1A	; 26
    7c8c:	70 e0       	ldi	r23, 0x00	; 0
    7c8e:	a8 de       	rcall	.-688    	; 0x79e0 <twi_master_read16_reg8>
    7c90:	28 2e       	mov	r2, r24
  crcc = isCrcOk(ic_addr);
    7c92:	30 90 02 01 	lds	r3, 0x0102	; 0x800102 <ic_addr>
static inline bool isCrcOk(const uint8_t i2c_address) {
    7c96:	2d b7       	in	r18, 0x3d	; 61
    7c98:	3e b7       	in	r19, 0x3e	; 62
    7c9a:	cf 57       	subi	r28, 0x7F	; 127
    7c9c:	df 4f       	sbci	r29, 0xFF	; 255
    7c9e:	39 83       	std	Y+1, r19	; 0x01
    7ca0:	28 83       	st	Y, r18
    7ca2:	c1 58       	subi	r28, 0x81	; 129
    7ca4:	d0 40       	sbci	r29, 0x00	; 0
  uint16_t start_address = mem_addr1;//0x0030;//mem_addr; WWWWWTTTTFFFFFFFFF!?!?!?!??!
    7ca6:	80 90 03 01 	lds	r8, 0x0103	; 0x800103 <mem_addr1>
    7caa:	90 90 04 01 	lds	r9, 0x0104	; 0x800104 <mem_addr1+0x1>
  uint16_t length = twi_master_read16_reg16(ic_addr, 32);
    7cae:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ic_addr>
    7cb2:	60 e2       	ldi	r22, 0x20	; 32
    7cb4:	70 e0       	ldi	r23, 0x00	; 0
    7cb6:	e6 de       	rcall	.-564    	; 0x7a84 <twi_master_read16_reg16>
    7cb8:	7c 01       	movw	r14, r24
  uint32_t table[crc_table_size];
    7cba:	8d b7       	in	r24, 0x3d	; 61
    7cbc:	9e b7       	in	r25, 0x3e	; 62
    7cbe:	94 50       	subi	r25, 0x04	; 4
    7cc0:	0f b6       	in	r0, 0x3f	; 63
    7cc2:	f8 94       	cli
    7cc4:	9e bf       	out	0x3e, r25	; 62
    7cc6:	0f be       	out	0x3f, r0	; 63
    7cc8:	8d bf       	out	0x3d, r24	; 61
    7cca:	ed b7       	in	r30, 0x3d	; 61
    7ccc:	fe b7       	in	r31, 0x3e	; 62
    7cce:	31 96       	adiw	r30, 0x01	; 1
    7cd0:	6f 01       	movw	r12, r30
  init_table(&table[0]);
    7cd2:	40 e0       	ldi	r20, 0x00	; 0
    7cd4:	50 e0       	ldi	r21, 0x00	; 0
    7cd6:	ba 01       	movw	r22, r20
    7cd8:	db 01       	movw	r26, r22
    7cda:	ca 01       	movw	r24, r20
    7cdc:	28 e0       	ldi	r18, 0x08	; 8
static uint32_t polynomial_representation = 0xEDB88320UL; //0xEDB88320UL;
static uint16_t crc_table_size = 0x100;

static inline uint32_t crc32_for_byte(uint32_t r) {
  for (uint8_t i = 0; i < 8; ++i) {
    r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
    7cde:	41 2c       	mov	r4, r1
    7ce0:	51 2c       	mov	r5, r1
    7ce2:	32 01       	movw	r6, r4
    7ce4:	80 fd       	sbrc	r24, 0
    7ce6:	08 c0       	rjmp	.+16     	; 0x7cf8 <main+0x8e>
    7ce8:	00 e2       	ldi	r16, 0x20	; 32
    7cea:	40 2e       	mov	r4, r16
    7cec:	03 e8       	ldi	r16, 0x83	; 131
    7cee:	50 2e       	mov	r5, r16
    7cf0:	08 eb       	ldi	r16, 0xB8	; 184
    7cf2:	60 2e       	mov	r6, r16
    7cf4:	0d ee       	ldi	r16, 0xED	; 237
    7cf6:	70 2e       	mov	r7, r16
    7cf8:	b6 95       	lsr	r27
    7cfa:	a7 95       	ror	r26
    7cfc:	97 95       	ror	r25
    7cfe:	87 95       	ror	r24
    7d00:	84 25       	eor	r24, r4
    7d02:	95 25       	eor	r25, r5
    7d04:	a6 25       	eor	r26, r6
    7d06:	b7 25       	eor	r27, r7
    7d08:	21 50       	subi	r18, 0x01	; 1
  for (uint8_t i = 0; i < 8; ++i) {
    7d0a:	49 f7       	brne	.-46     	; 0x7cde <main+0x74>
  }
  return r ^ (uint32_t)0xFF000000L;
    7d0c:	b0 95       	com	r27
}

static inline void init_table(uint32_t *crc_table) {
  for (uint16_t i = 0; i < crc_table_size; ++i) {
    crc_table[i] = crc32_for_byte(i);
    7d0e:	81 93       	st	Z+, r24
    7d10:	91 93       	st	Z+, r25
    7d12:	a1 93       	st	Z+, r26
    7d14:	b1 93       	st	Z+, r27
    7d16:	4f 5f       	subi	r20, 0xFF	; 255
    7d18:	5f 4f       	sbci	r21, 0xFF	; 255
    7d1a:	6f 4f       	sbci	r22, 0xFF	; 255
    7d1c:	7f 4f       	sbci	r23, 0xFF	; 255
  for (uint16_t i = 0; i < crc_table_size; ++i) {
    7d1e:	41 15       	cp	r20, r1
    7d20:	21 e0       	ldi	r18, 0x01	; 1
    7d22:	52 07       	cpc	r21, r18
    7d24:	61 05       	cpc	r22, r1
    7d26:	71 05       	cpc	r23, r1
    7d28:	b9 f6       	brne	.-82     	; 0x7cd8 <main+0x6e>
  uint32_t crc = 0;
    7d2a:	41 2c       	mov	r4, r1
    7d2c:	51 2c       	mov	r5, r1
    7d2e:	32 01       	movw	r6, r4
  for (uint16_t pos = 0; pos < length + 1; pos += 2) {
    7d30:	10 e0       	ldi	r17, 0x00	; 0
    7d32:	00 e0       	ldi	r16, 0x00	; 0
    7d34:	c7 01       	movw	r24, r14
    7d36:	01 96       	adiw	r24, 0x01	; 1
    7d38:	cd 57       	subi	r28, 0x7D	; 125
    7d3a:	df 4f       	sbci	r29, 0xFF	; 255
    7d3c:	99 83       	std	Y+1, r25	; 0x01
    7d3e:	88 83       	st	Y, r24
    7d40:	c3 58       	subi	r28, 0x83	; 131
    7d42:	d0 40       	sbci	r29, 0x00	; 0
    if (pos == length - 1)
    7d44:	57 01       	movw	r10, r14
    7d46:	91 e0       	ldi	r25, 0x01	; 1
    7d48:	a9 1a       	sub	r10, r25
    7d4a:	b1 08       	sbc	r11, r1
  for (uint16_t pos = 0; pos < length + 1; pos += 2) {
    7d4c:	cd 57       	subi	r28, 0x7D	; 125
    7d4e:	df 4f       	sbci	r29, 0xFF	; 255
    7d50:	88 81       	ld	r24, Y
    7d52:	99 81       	ldd	r25, Y+1	; 0x01
    7d54:	c3 58       	subi	r28, 0x83	; 131
    7d56:	d0 40       	sbci	r29, 0x00	; 0
    7d58:	08 17       	cp	r16, r24
    7d5a:	19 07       	cpc	r17, r25
    7d5c:	08 f4       	brcc	.+2      	; 0x7d60 <main+0xf6>
    7d5e:	7c c0       	rjmp	.+248    	; 0x7e58 <main+0x1ee>
  uint32_t expected_crc = (uint32_t)(twi_master_read16_reg16(i2c_address, application_crc_expected_index))<< 16;
    7d60:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <application_crc_expected_index>
    7d64:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <application_crc_expected_index+0x1>
    7d68:	83 2d       	mov	r24, r3
    7d6a:	8c de       	rcall	.-744    	; 0x7a84 <twi_master_read16_reg16>
    7d6c:	b0 e0       	ldi	r27, 0x00	; 0
    7d6e:	a0 e0       	ldi	r26, 0x00	; 0
    7d70:	7c 01       	movw	r14, r24
    7d72:	dd 24       	eor	r13, r13
    7d74:	cc 24       	eor	r12, r12
  expected_crc |= (uint32_t)(twi_master_read16_reg16(i2c_address, application_crc_expected_index + 2));
    7d76:	60 91 00 01 	lds	r22, 0x0100	; 0x800100 <application_crc_expected_index>
    7d7a:	70 91 01 01 	lds	r23, 0x0101	; 0x800101 <application_crc_expected_index+0x1>
    7d7e:	6e 5f       	subi	r22, 0xFE	; 254
    7d80:	7f 4f       	sbci	r23, 0xFF	; 255
    7d82:	83 2d       	mov	r24, r3
    7d84:	7f de       	rcall	.-770    	; 0x7a84 <twi_master_read16_reg16>
    7d86:	b0 e0       	ldi	r27, 0x00	; 0
    7d88:	a0 e0       	ldi	r26, 0x00	; 0
    7d8a:	8c 29       	or	r24, r12
    7d8c:	9d 29       	or	r25, r13
    7d8e:	ae 29       	or	r26, r14
    7d90:	bf 29       	or	r27, r15
    7d92:	cf 57       	subi	r28, 0x7F	; 127
    7d94:	df 4f       	sbci	r29, 0xFF	; 255
    7d96:	e8 81       	ld	r30, Y
    7d98:	f9 81       	ldd	r31, Y+1	; 0x01
    7d9a:	c1 58       	subi	r28, 0x81	; 129
    7d9c:	d0 40       	sbci	r29, 0x00	; 0
    7d9e:	0f b6       	in	r0, 0x3f	; 63
    7da0:	f8 94       	cli
    7da2:	fe bf       	out	0x3e, r31	; 62
    7da4:	0f be       	out	0x3f, r0	; 63
    7da6:	ed bf       	out	0x3d, r30	; 61
  
  if (dc == 0x11 && crcc == 1)
    7da8:	f1 e1       	ldi	r31, 0x11	; 17
    7daa:	2f 12       	cpse	r2, r31
    7dac:	52 c0       	rjmp	.+164    	; 0x7e52 <main+0x1e8>
    7dae:	84 15       	cp	r24, r4
    7db0:	95 05       	cpc	r25, r5
    7db2:	a6 05       	cpc	r26, r6
    7db4:	b7 05       	cpc	r27, r7
    7db6:	09 f0       	breq	.+2      	; 0x7dba <main+0x150>
    7db8:	4c c0       	rjmp	.+152    	; 0x7e52 <main+0x1e8>
  {
    twi_master_write16_reg8(ic_addr, 26, 0xFF);
    7dba:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ic_addr>
    7dbe:	4f ef       	ldi	r20, 0xFF	; 255
    7dc0:	6a e1       	ldi	r22, 0x1A	; 26
    7dc2:	70 e0       	ldi	r23, 0x00	; 0
    7dc4:	c3 de       	rcall	.-634    	; 0x7b4c <twi_master_write16_reg8>
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
    7dc6:	00 e0       	ldi	r16, 0x00	; 0
    7dc8:	18 e7       	ldi	r17, 0x78	; 120
    boot_page_erase(ptr);
    7dca:	83 e0       	ldi	r24, 0x03	; 3
    ptr -= SPM_PAGESIZE;
    7dcc:	00 58       	subi	r16, 0x80	; 128
    7dce:	11 09       	sbc	r17, r1
    boot_page_erase(ptr);
    7dd0:	f8 01       	movw	r30, r16
    7dd2:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7dd6:	e8 95       	spm
    boot_spm_busy_wait();
    7dd8:	07 b6       	in	r0, 0x37	; 55
    7dda:	00 fc       	sbrc	r0, 0
    7ddc:	fd cf       	rjmp	.-6      	; 0x7dd8 <main+0x16e>
  } while (ptr);
    7dde:	01 15       	cp	r16, r1
    7de0:	11 05       	cpc	r17, r1
    7de2:	a1 f7       	brne	.-24     	; 0x7dcc <main+0x162>
    eraseApplication();
    writeFlashFromI2C(ic_addr); //, application_start);
    7de4:	40 90 02 01 	lds	r4, 0x0102	; 0x800102 <ic_addr>
  uint16_t start_address = mem_addr1;
    7de8:	60 90 03 01 	lds	r6, 0x0103	; 0x800103 <mem_addr1>
    7dec:	70 90 04 01 	lds	r7, 0x0104	; 0x800104 <mem_addr1+0x1>
  uint16_t length = twi_master_read16_reg16(ic_addr, 32);
    7df0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ic_addr>
    7df4:	60 e2       	ldi	r22, 0x20	; 32
    7df6:	70 e0       	ldi	r23, 0x00	; 0
    7df8:	45 de       	rcall	.-886    	; 0x7a84 <twi_master_read16_reg16>
    7dfa:	4c 01       	movw	r8, r24
  uint8_t writes = 0;
    7dfc:	51 2c       	mov	r5, r1
    7dfe:	9e 01       	movw	r18, r28
    7e00:	2f 5f       	subi	r18, 0xFF	; 255
    7e02:	3f 4f       	sbci	r19, 0xFF	; 255
    7e04:	79 01       	movw	r14, r18
    7e06:	85 2d       	mov	r24, r5
    7e08:	90 e0       	ldi	r25, 0x00	; 0
    7e0a:	6c 01       	movw	r12, r24
    7e0c:	d6 94       	lsr	r13
    7e0e:	dc 2c       	mov	r13, r12
    7e10:	cc 24       	eor	r12, r12
    7e12:	d7 94       	ror	r13
    7e14:	c7 94       	ror	r12
  for (uint16_t pos = 0; pos < length; pos += 2) {
    7e16:	08 15       	cp	r16, r8
    7e18:	19 05       	cpc	r17, r9
    7e1a:	08 f4       	brcc	.+2      	; 0x7e1e <main+0x1b4>
    7e1c:	55 c0       	rjmp	.+170    	; 0x7ec8 <main+0x25e>
  for (uint16_t pos = SPM_PAGESIZE - ((uint16_t)(writes + 1) *(uint16_t)(SPM_PAGESIZE)) % length; pos < SPM_PAGESIZE; ++pos) {
    7e1e:	01 96       	adiw	r24, 0x01	; 1
    7e20:	96 95       	lsr	r25
    7e22:	98 2f       	mov	r25, r24
    7e24:	88 27       	eor	r24, r24
    7e26:	97 95       	ror	r25
    7e28:	87 95       	ror	r24
    7e2a:	b4 01       	movw	r22, r8
    7e2c:	72 d0       	rcall	.+228    	; 0x7f12 <__udivmodhi4>
    7e2e:	f7 01       	movw	r30, r14
    7e30:	e8 1b       	sub	r30, r24
    7e32:	f9 0b       	sbc	r31, r25
    7e34:	e0 58       	subi	r30, 0x80	; 128
    7e36:	ff 4f       	sbci	r31, 0xFF	; 255
    buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
    7e38:	2f ef       	ldi	r18, 0xFF	; 255
  for (uint16_t pos = SPM_PAGESIZE - ((uint16_t)(writes + 1) *(uint16_t)(SPM_PAGESIZE)) % length; pos < SPM_PAGESIZE; ++pos) {
    7e3a:	cf 01       	movw	r24, r30
    7e3c:	8e 19       	sub	r24, r14
    7e3e:	9f 09       	sbc	r25, r15
    7e40:	80 38       	cpi	r24, 0x80	; 128
    7e42:	91 05       	cpc	r25, r1
    7e44:	08 f4       	brcc	.+2      	; 0x7e48 <main+0x1de>
    7e46:	63 c0       	rjmp	.+198    	; 0x7f0e <main+0x2a4>
  writeToPageBuffer(address, data);
    7e48:	b7 01       	movw	r22, r14
    7e4a:	c6 01       	movw	r24, r12
    7e4c:	30 dd       	rcall	.-1440   	; 0x78ae <writeToPageBuffer>
  writePageBufferToFlash(address);
    7e4e:	c6 01       	movw	r24, r12
    7e50:	53 dd       	rcall	.-1370   	; 0x78f8 <writePageBufferToFlash>
        source_i2c_address_for_program, application_start_address_byte_offset);

    application_start = address_in_external_eeprom >> 8;
    application_start |= static_cast<uint8_t>(address_in_external_eeprom);
  }*/
  jump_to_app();
    7e52:	f0 e0       	ldi	r31, 0x00	; 0
    7e54:	e0 e0       	ldi	r30, 0x00	; 0
    7e56:	09 95       	icall
    if (pos >= length)
    7e58:	0e 15       	cp	r16, r14
    7e5a:	1f 05       	cpc	r17, r15
    7e5c:	08 f0       	brcs	.+2      	; 0x7e60 <main+0x1f6>
    7e5e:	80 cf       	rjmp	.-256    	; 0x7d60 <main+0xf6>
    uint16_t data = twi_master_read16_reg16(ic_addr, pos + start_address);
    7e60:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ic_addr>
    7e64:	b4 01       	movw	r22, r8
    7e66:	60 0f       	add	r22, r16
    7e68:	71 1f       	adc	r23, r17
    7e6a:	0c de       	rcall	.-1000   	; 0x7a84 <twi_master_read16_reg16>
    if (pos == length - 1)
    7e6c:	0a 15       	cp	r16, r10
    7e6e:	1b 05       	cpc	r17, r11
    7e70:	09 f4       	brne	.+2      	; 0x7e74 <main+0x20a>
      data &= 0xFF00;
    7e72:	88 27       	eor	r24, r24
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[(uint8_t)(*crc) ^ ((uint8_t *)data)[i]] ^
    7e74:	e9 2f       	mov	r30, r25
    7e76:	e4 25       	eor	r30, r4
    7e78:	24 e0       	ldi	r18, 0x04	; 4
    7e7a:	e2 9f       	mul	r30, r18
    7e7c:	f0 01       	movw	r30, r0
    7e7e:	11 24       	eor	r1, r1
    7e80:	ec 0d       	add	r30, r12
    7e82:	fd 1d       	adc	r31, r13
           *crc >> 8;
    7e84:	45 2c       	mov	r4, r5
    7e86:	56 2c       	mov	r5, r6
    7e88:	67 2c       	mov	r6, r7
    7e8a:	77 24       	eor	r7, r7
    *crc = crc_table[(uint8_t)(*crc) ^ ((uint8_t *)data)[i]] ^
    7e8c:	40 81       	ld	r20, Z
    7e8e:	51 81       	ldd	r21, Z+1	; 0x01
    7e90:	62 81       	ldd	r22, Z+2	; 0x02
    7e92:	73 81       	ldd	r23, Z+3	; 0x03
    7e94:	44 26       	eor	r4, r20
    7e96:	55 26       	eor	r5, r21
    7e98:	66 26       	eor	r6, r22
    7e9a:	77 26       	eor	r7, r23
  for (uint16_t pos = 0; pos < length + 1; pos += 2) {
    7e9c:	0e 5f       	subi	r16, 0xFE	; 254
    7e9e:	1f 4f       	sbci	r17, 0xFF	; 255
    7ea0:	84 25       	eor	r24, r4
    7ea2:	34 e0       	ldi	r19, 0x04	; 4
    7ea4:	83 9f       	mul	r24, r19
    7ea6:	f0 01       	movw	r30, r0
    7ea8:	11 24       	eor	r1, r1
    7eaa:	ec 0d       	add	r30, r12
    7eac:	fd 1d       	adc	r31, r13
           *crc >> 8;
    7eae:	45 2c       	mov	r4, r5
    7eb0:	56 2c       	mov	r5, r6
    7eb2:	67 2c       	mov	r6, r7
    7eb4:	77 24       	eor	r7, r7
    *crc = crc_table[(uint8_t)(*crc) ^ ((uint8_t *)data)[i]] ^
    7eb6:	80 81       	ld	r24, Z
    7eb8:	91 81       	ldd	r25, Z+1	; 0x01
    7eba:	a2 81       	ldd	r26, Z+2	; 0x02
    7ebc:	b3 81       	ldd	r27, Z+3	; 0x03
    7ebe:	48 26       	eor	r4, r24
    7ec0:	59 26       	eor	r5, r25
    7ec2:	6a 26       	eor	r6, r26
    7ec4:	7b 26       	eor	r7, r27
    7ec6:	42 cf       	rjmp	.-380    	; 0x7d4c <main+0xe2>
    7ec8:	58 01       	movw	r10, r16
    7eca:	e8 94       	clt
    7ecc:	a7 f8       	bld	r10, 7
    7ece:	bb 24       	eor	r11, r11
    if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
    7ed0:	01 15       	cp	r16, r1
    7ed2:	11 05       	cpc	r17, r1
    7ed4:	49 f0       	breq	.+18     	; 0x7ee8 <main+0x27e>
    7ed6:	a1 14       	cp	r10, r1
    7ed8:	b1 04       	cpc	r11, r1
    7eda:	31 f4       	brne	.+12     	; 0x7ee8 <main+0x27e>
  writeToPageBuffer(address, data);
    7edc:	b7 01       	movw	r22, r14
    7ede:	c6 01       	movw	r24, r12
    7ee0:	e6 dc       	rcall	.-1588   	; 0x78ae <writeToPageBuffer>
  writePageBufferToFlash(address);
    7ee2:	c6 01       	movw	r24, r12
    7ee4:	09 dd       	rcall	.-1518   	; 0x78f8 <writePageBufferToFlash>
      ++writes;
    7ee6:	53 94       	inc	r5
    uint16_t data = twi_master_read16_reg16(i2c_address, pos + start_address);
    7ee8:	b3 01       	movw	r22, r6
    7eea:	60 0f       	add	r22, r16
    7eec:	71 1f       	adc	r23, r17
    7eee:	84 2d       	mov	r24, r4
    7ef0:	c9 dd       	rcall	.-1134   	; 0x7a84 <twi_master_read16_reg16>
    buf[pos % SPM_PAGESIZE] = (uint8_t)(data >> 8);
    7ef2:	f7 01       	movw	r30, r14
    7ef4:	ea 0d       	add	r30, r10
    7ef6:	fb 1d       	adc	r31, r11
    7ef8:	90 83       	st	Z, r25
    buf[(pos + 1) % SPM_PAGESIZE] = (uint8_t)(data);
    7efa:	f8 01       	movw	r30, r16
    7efc:	31 96       	adiw	r30, 0x01	; 1
    7efe:	ef 77       	andi	r30, 0x7F	; 127
    7f00:	ff 27       	eor	r31, r31
    7f02:	ee 0d       	add	r30, r14
    7f04:	ff 1d       	adc	r31, r15
    7f06:	80 83       	st	Z, r24
  for (uint16_t pos = 0; pos < length; pos += 2) {
    7f08:	0e 5f       	subi	r16, 0xFE	; 254
    7f0a:	1f 4f       	sbci	r17, 0xFF	; 255
    7f0c:	7c cf       	rjmp	.-264    	; 0x7e06 <main+0x19c>
    buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
    7f0e:	21 93       	st	Z+, r18
    7f10:	94 cf       	rjmp	.-216    	; 0x7e3a <main+0x1d0>

00007f12 <__udivmodhi4>:
    7f12:	aa 1b       	sub	r26, r26
    7f14:	bb 1b       	sub	r27, r27
    7f16:	51 e1       	ldi	r21, 0x11	; 17
    7f18:	07 c0       	rjmp	.+14     	; 0x7f28 <__udivmodhi4_ep>

00007f1a <__udivmodhi4_loop>:
    7f1a:	aa 1f       	adc	r26, r26
    7f1c:	bb 1f       	adc	r27, r27
    7f1e:	a6 17       	cp	r26, r22
    7f20:	b7 07       	cpc	r27, r23
    7f22:	10 f0       	brcs	.+4      	; 0x7f28 <__udivmodhi4_ep>
    7f24:	a6 1b       	sub	r26, r22
    7f26:	b7 0b       	sbc	r27, r23

00007f28 <__udivmodhi4_ep>:
    7f28:	88 1f       	adc	r24, r24
    7f2a:	99 1f       	adc	r25, r25
    7f2c:	5a 95       	dec	r21
    7f2e:	a9 f7       	brne	.-22     	; 0x7f1a <__udivmodhi4_loop>
    7f30:	80 95       	com	r24
    7f32:	90 95       	com	r25
    7f34:	bc 01       	movw	r22, r24
    7f36:	cd 01       	movw	r24, r26
    7f38:	08 95       	ret

00007f3a <_exit>:
    7f3a:	f8 94       	cli

00007f3c <__stop_program>:
    7f3c:	ff cf       	rjmp	.-2      	; 0x7f3c <__stop_program>
